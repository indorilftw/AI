%{{{packages
\documentclass[a4paper,12pt]{article}
\usepackage{anysize}
\marginsize{2cm}{2cm}{1cm}{1cm}
%\textwidth 6.0in \textheight = 664pt
\usepackage{xltxtra}
\usepackage{hyperref}
\usepackage{xunicode}
\usepackage{graphicx}
\usepackage{color}
\usepackage{xgreek}
\usepackage{fancyvrb}
\usepackage{minted}
\usepackage{listings}
\usepackage{enumitem}
\usepackage{framed}
\usepackage{relsize}
\usepackage{float}
\setmainfont[Mapping=TeX-text]{DejaVu Sans}
%}}}
\begin{document}

\include{title/title}

\section*{Υλοποίηση αλγορίθμου A*} \setcounter{section}{1}
\subsection{Παρουσίαση προβλήματος και σκιαγράφηση λύσης}
Στην άσκηση αυτή καλούμαστε να υλοποιήσουμε τον αλγόριθμο αναζήτησης Α* με
σκοπό να οδηγηθούν με βέλτιστο τρόπο 2 ρομπότ σε ένα προκαθορισμένο σημείο
συνάντησης, αποφεύγοντας τις πιθανές συγκρούσεις.

Έχοντας ως δεδομένο ότι τα δύο ρομπότ έχουν γνώση της θέσης και του
πλάνου του άλλου ρομπότ, καθώς και πλήρη γνώση της αίθουσας, επιλέξαμε να
κάνουμε μια παρατήρηση /παραδοχή που διευκολύνει σημαντικά την δομή του
προγράμματός μας:

Αντί τα 2 ρομπότ να πραγματοποιούν τις κινήσεις/επιλογές τους εναλλάξ,
θεωρούμε, χωρίς βλάβη της γενικότητας, ότι στις συγκρούσεις το 2ο ρομπότ θα
έχει μια 'nice' συμπεριφορά, παραχωρόντας τη βέλτιστη κίνηση στο 1ο ρομπότ. Με
τον τρόπο αυτό, μπορούμε να εκτελέσουμε σειριακά τον αλγόριθμο A*, πρώτα για
το 1ο ρομπότ και στη συνέχεια για το 2ο, έχοντας ήδη δεδομένες τις κινήσεις
του 1ου.

Ο χώρος των καταστάσεων μας δίνεται ως ένα grid με Ο (στις θέσεις που
επιτρέπεται η κίνηση) και Χ (στις θέσεις όπου βρίσκονται εμπόδια). Η βασική
ιδέα πίσω από τον αλγόριθμό μας είναι ότι οι θέσεις με Χ κωδικοποιούνται ως
'-1', οι θέσεις με O με '0', ενώ η θέση στην οποία θα βρίσκεται το 1ο ρομπότ
στο k-οστό βήμα με 'k'.

Με τον τρόπο αυτό, μπορούμε να περιορίσουμε τις επιλογές του 2ου ρομπότ σε
κάθε βήμα, αναγκάζοντας το να ψάξει εναλλακτικό μονοπάτι ή να μείνει στάσιμο
γι'αυτό το βήμα (αν το συμφέρει). Καταφέρνουμε έτσι να αποφύγουμε τις πιθανές
συγκρούσεις, ενώ ταυτόχρονα δε θυσιάζουμε τη βελτιστότητα της λύσης μας.

Για την υλοποίηση του παραπάνω αλγορίθμου, επιλέχθηκε ως κατάλληλη γλώσσα η
Python, επειδή μας δίνει τη δυνατότητα να επικεντρωθούμε στα πλέον σημαντικά
κομμάτια του προβλήματος (αλγόριθμος και στρατηγική αναζήτησης), να γράψουμε
πυκνό και ευανάγνωστο κώδικα, ενώ με τη χρήση ενός Just-in-time compiler όπως
o \underline{\href{http://psyco.sourceforge.net/}{Psycho}} έχουμε ίδιο χρόνο
εκτέλεσης όπως αν γράφαμε σε μια γλώσσα χαμηλότερου επιπέδου.

\subsection{Επιλογή Δομών Δεδομένων}
Στην υλοποίησή μας επιλέξαμε να χρησιμοποιήσουμε λίστες λιστών της Python,
όπου ο κάθε κόμβος στι λίστα του A* είχε 4 στοιχεία:
\begin{enumerate}
    \item Το άθροισμα ευριστικής και κόστους (h + c)
    \item Το κόστος (c)
    \item Την τετμημένη του σημείου (x)
    \item Την τεταγμένη του σημείου (y)
\end{enumerate}

Επιπλέον, χρησιμοποιείται ένα λεξικό (dict) προκειμένου να
πραγματοποιηθεί η αναδόμηση της επιλεγμένης διαδρομής ενός ρομπότ. Τα
dictionaries είναι associative arrays, ένας τύπος αντικειμένων που μοιάζει με
λίστα, αλλά όπου σε μοναδικά κλειδιά αντιστοιχίζονται (όχι απαραίτητα
μοναδικές) τιμές.
\subsection{Βασικές συναρτήσεις-τελεστές}
2
\subsection{Ευριστικές μέθοδοι}
Δεδομένου ότι δουλεύουμε σε δισδιάστατο χώρο με μόνο οριζόντια και κάθετη
κίνηση (όχι διαγώνια), επιλέχθηκε ως πιο έγκυρος και αποδοτικός υποεκτιμητής η
απόστατη Manhattan:
\begin{center} $M\_D = |x_1 - x_2| + |y_1 - y_2|$\end{center}
\subsection{Έλεγχος και επίλυση συγκρούσεων}
4
\subsection{Χρόνος εκτέλεσης ανά μέγεθος εισόδου}
5
\subsection{Εκτύπωση βημάτων-συγκρούσεων-εναλλακτικών δρόμων σε παράδειγμα
εκτέλεσης}
6
\subsection{Πηγαίος κώδικας}
Here be dragons!

\end{document}
